#include <iostream>
#include <memory>

#include <UHH2/core/include/AnalysisModule.h>
#include <UHH2/core/include/Event.h>
#include <UHH2/common/include/EventHists.h>
#include <UHH2/core/include/Selection.h>

#include <UHH2/common/include/MCWeight.h>
#include <UHH2/common/include/CommonModules.h>
#include <UHH2/common/include/CleaningModules.h>
#include <UHH2/common/include/NSelections.h>
#include <UHH2/common/include/LumiSelection.h>
#include <UHH2/common/include/TriggerSelection.h>
#include <UHH2/common/include/JetCorrections.h>
#include <UHH2/common/include/ObjectIdUtils.h>
#include <UHH2/common/include/MuonIds.h>
#include <UHH2/common/include/MuonHists.h>
#include <UHH2/common/include/ElectronIds.h>
#include <UHH2/common/include/ElectronHists.h>
#include <UHH2/common/include/JetIds.h>
#include <UHH2/common/include/JetHists.h>
#include <UHH2/common/include/TopJetIds.h>
#include <UHH2/common/include/TTbarGen.h>
#include <UHH2/common/include/TTbarReconstruction.h>
#include <UHH2/common/include/ReconstructionHypothesis.h>
#include <UHH2/common/include/ReconstructionHypothesisDiscriminators.h>
#include <UHH2/common/include/HypothesisHists.h>
#include <UHH2/common/include/Utils.h>
#include "UHH2/common/include/PrintingModules.h"
#include "UHH2/common/include/TopPtReweight.h"

#include <UHH2/TstarSemiLeptonic/include/HypothesisHistsOwn.h>
#include <UHH2/TstarSemiLeptonic/include/TStarGen.h>
#include <UHH2/TstarSemiLeptonic/include/TStarGenHists.h>
#include <UHH2/TstarSemiLeptonic/include/TstarSelectionHists.h>
#include <UHH2/TstarSemiLeptonic/include/TstarReconstruction.h>
#include <UHH2/TstarSemiLeptonic/include/TstarReconstructionHypothesis.h>
#include <UHH2/TstarSemiLeptonic/include/TstarReconstructionHypothesisDiscriminators.h>



#include <UHH2/TstarSemiLeptonic/include/TstarSemiLeptonicSelections.h>
#include <UHH2/TstarSemiLeptonic/include/TstarSemiLeptonicUtils.h>

using namespace std;

/** \brief module to produce "Control Selection" ntuples for theT*T*->tg tg semileptonic analysis
 *
 *  -- GOALS:
 *   * complete object reconstruction (pt/eta cuts, IDs, jet-lepton cleaning, JER smearing)
 *   * apply (most of) the kinematic cuts for the lepton+jets SR. current cutflow:

 *     * JER smearing for TopJet collection
 *     * Common Modules 
 *     * HLT
 *     * ==1 lepton (w/ pt+eta+ID cuts)
 *     * >=4 AK4 jets w/ pt> 30 |eta|<2.4
 *     * >=1 AK4 jets w/ pt>200 |eta|<2.4
 *     * lepton-2D-cut [DR>0.4 || pTrel>40 GeV] (wrt AK4 jets w/ pt>25 GeV)
 *     * (electron-only) triangular cuts
 *     * perform T*T*bar kinematical reconstruction (hyps stored in output ntuple)
 *     * Reconstruction without TopTag 
 *
 *   * JER smearing for TopJet collection
 *   * update 2D cut values (validation ongoing)
 *
 */


class TstarSelectionControl : public uhh2::AnalysisModule {

 public:
  explicit TstarSelectionControl(uhh2::Context&);
  virtual bool process(uhh2::Event&) override;

 private:
  enum lepton { muon, elec };
  lepton channel_;

  uhh2::Event::Handle<int> h_flag_toptagevent;

  // common modules
  std::unique_ptr<CommonModules>  common;
  std::unique_ptr<AnalysisModule> Muon_printer, Electron_printer, Jet_printer, GenParticles_printer;
  std::unique_ptr<TopPtReweight> ttbar_reweight;
  
  // cleaners
  std::unique_ptr<JetCleaner>                 jet_cleaner1;
  std::unique_ptr<JetCleaner>                 jet_cleaner2;
  std::unique_ptr<JetCleaner>                 topjet_IDcleaner;
  std::unique_ptr<TopJetCorrector>            topjet_corrector;
  //std::unique_ptr<TopJetResolutionSmearer>    topjetER_smearer;
  std::unique_ptr<TopJetLeptonDeltaRCleaner>  topjetlepton_cleaner;
  std::unique_ptr<TopJetCleaner>              topjet_cleaner;

  // selections
  std::unique_ptr<uhh2::Selection>    trigger_sel;
  std::unique_ptr<uhh2::AndSelection> lep1_sel;
  std::unique_ptr<uhh2::Selection>    jet2_sel;
  std::unique_ptr<uhh2::Selection>    jet1_sel;
  std::unique_ptr<uhh2::Selection>    b_tag_loose_sel;
  std::unique_ptr<uhh2::Selection>    b_tag_medium_sel;
  std::unique_ptr<uhh2::Selection>    b_tag_tight_sel;
  std::unique_ptr<uhh2::Selection>    ht_sel;
  std::unique_ptr<uhh2::Selection>    twodcut_sel;
  std::unique_ptr<uhh2::Selection>    triangc_sel;
  std::unique_ptr<uhh2::Selection>    toptagevt_sel;

  // ttbar reconstruction
  std::unique_ptr<uhh2::AnalysisModule> reco_primlep;
  std::unique_ptr<uhh2::AnalysisModule> ttgenprod;

  //T*T*  reconstruction
  std::unique_ptr<uhh2::AnalysisModule> tstargenprod;
  std::unique_ptr<uhh2::AnalysisModule> tstar_reco;  
  std::unique_ptr<uhh2::AnalysisModule> tstar_ttag_reco;
  std::unique_ptr<uhh2::AnalysisModule> tstar_chi2;
  std::unique_ptr<uhh2::AnalysisModule> tstar_ttag_chi2;
  std::unique_ptr<uhh2::AnalysisModule> tstar_match;

 
  ////HISTS
  std::unique_ptr<uhh2::Hists> chi2min_h;
  std::unique_ptr<uhh2::Hists> chi2min_ttag_h;
  std::unique_ptr<uhh2::Hists> chi2min_ttag_comb_h;

  std::unique_ptr<uhh2::Hists> corrmatch_h;

  std::unique_ptr<Hists> input_h_event, input_h_bJet, input_h_jet, input_h_ele, input_h_muo, input_h_topjet;
  std::unique_ptr<Hists> trigger_h_event, trigger_h_bJet, trigger_h_jet, trigger_h_ele, trigger_h_muo, trigger_h_topjet; 
  std::unique_ptr<Hists> lep1_h_event, lep1_h_bJet, lep1_h_jet, lep1_h_ele, lep1_h_muo, lep1_h_topjet;
  std::unique_ptr<Hists> jet2_h_event, jet2_h_bJet, jet2_h_jet, jet2_h_ele, jet2_h_muo, jet2_h_topjet;
  std::unique_ptr<Hists> jet1_h_event, jet1_h_bJet, jet1_h_jet, jet1_h_ele, jet1_h_muo, jet1_h_topjet;
  std::unique_ptr<Hists> twodcut_h_event, twodcut_h_bJet, twodcut_h_jet, twodcut_h_ele, twodcut_h_muo, twodcut_h_topjet;
  std::unique_ptr<Hists> triangc_h_event, triangc_h_bJet, triangc_h_jet, triangc_h_ele, triangc_h_muo, triangc_h_topjet;
  std::unique_ptr<Hists> toptagevt_h_event, toptagevt_h_bJet, toptagevt_h_jet, toptagevt_h_ele, toptagevt_h_muo, toptagevt_h_topjet;
  std::unique_ptr<Hists> output_h_event, output_h_bJet, output_h_jet, output_h_ele, output_h_muo, output_h_topjet;


  MuonId     MuId;
  ElectronId EleId;
  JetId      Btag_loose, Btag_medium, Btag_tight;

  uhh2::Event::Handle<std::vector<TstarReconstructionHypothesis>> h_hyps;
};


TstarSelectionControl::TstarSelectionControl(uhh2::Context& ctx){
  
  std::cout << "Hello World from TstarSelectionControl!" << std::endl;

  ///PRINTER MODULES
  //Jet_printer         .reset(new JetPrinter("Jet-Printer", 0));
  //Electron_printer    .reset(new ElectronPrinter("Electron-Printer"));
  //Muon_printer        .reset(new MuonPrinter("Muon-Printer"));
    //GenParticles_printer.reset(new GenParticlesPrinter(ctx));
    ///   

    MuId  = AndId<Muon>(MuonIDMedium(), PtEtaCut(50., 2.1));
    EleId = AndId<Electron>(ElectronID_MVAnotrig_Spring15_25ns_loose, PtEtaSCCut(50., 2.5));
    const JetId jetID(JetPFID(JetPFID::WP_LOOSE));

    ttbar_reweight.reset(new TopPtReweight(ctx,0.159,-0.00141,"","weight_ttbar",true,0.9910819));

  ///CommonModules
    common.reset(new CommonModules());
    //common->disable_mcpileupreweight();
    //common->disable_lumisel();
    //common->disable_jersmear();
    //common->disable_jec();
    //common->disable_metfilters();
    //common->disable_pvfilter();
    common->switch_jetlepcleaner(true);
    common->set_electron_id(EleId);
    common->set_muon_id(MuId);
    common->set_jet_id(jetID);
    common->switch_jetPtSorter(true);
    common->init(ctx);
    ///

    ///Cannel and Top Jet Corrections
  const std::string& channel = ctx.get("channel", "");
  if     (channel == "muon") channel_ = muon;
  else if(channel == "elec") channel_ = elec;
  else throw std::runtime_error("ZprimeSelectionModule -- undefined argument for 'channel' key in xml file (must be 'muon' or 'elec'): "+channel);
  
  const bool isMC = (ctx.get("dataset_type") == "MC");

  std::vector<std::string> JEC_AK4, JEC_AK8;
   if(isMC){
    JEC_AK4 = JERFiles::Fall15_25ns_L123_AK4PFchs_MC;
    JEC_AK8 = JERFiles::Fall15_25ns_L123_AK8PFchs_MC;
  }
  else {
    JEC_AK4 = JERFiles::Fall15_25ns_L123_AK4PFchs_DATA;
    JEC_AK8 = JERFiles::Fall15_25ns_L123_AK8PFchs_DATA;
  }

   //// CLEANER
   jet_cleaner1        .reset(new JetCleaner(ctx, 15., 2.4));
   jet_cleaner2        .reset(new JetCleaner(ctx, 30., 2.4));
   topjet_IDcleaner    .reset(new JetCleaner(ctx, jetID));
   topjet_corrector    .reset(new TopJetCorrector(ctx, JEC_AK8));
   //topjetER_smearer  .reset(new TopJetResolutionSmearer(ctx));
   topjetlepton_cleaner.reset(new TopJetLeptonDeltaRCleaner(.8));
   topjet_cleaner      .reset(new TopJetCleaner(ctx, TopJetId(PtEtaCut(250., 2.4))));
   ///

  //// EVENT SELECTION
  const std::string trigger = ctx.get("trigger", "NULL");

  lep1_sel.reset(new uhh2::AndSelection(ctx));
  if(channel_ == muon){
    lep1_sel->add<NMuonSelection>    ("muoN == 1", 1, 1);
    lep1_sel->add<NElectronSelection>("eleN == 0", 0, 0);

    if(trigger != "NULL") trigger_sel.reset( new TriggerSelection(trigger));
    else                  trigger_sel.reset(new TriggerSelection("HLT_Mu45_eta2p1_v*"));
  }
  else if(channel_ == elec){
    lep1_sel->add<NMuonSelection>    ("muoN == 0", 0, 0);
    lep1_sel->add<NElectronSelection>("eleN == 1", 1, 1);

    if(trigger != "NULL") trigger_sel.reset(new TriggerSelection(trigger));
    else                  trigger_sel.reset(new TriggerSelection("HLT_Ele45_CaloIdVT_GsfTrkIdT_PFJet200_PFJet50_v*"));
  }

  ///Jet Selection
  jet2_sel.reset(new NJetSelection(4, -1, JetId(PtEtaCut( 30., 2.4)))); 
  jet1_sel.reset(new NJetSelection(1, -1, JetId(PtEtaCut(200., 2.4))));
  ///
 
 ///2D Cut Lepton-Jets
  twodcut_sel.reset(new TwoDCut(.4, 40.)); //New Cut, because QCD Problems
  ///

  ///Triangic Cut Electron and Jet
  if     (channel_ == elec) triangc_sel.reset(new TriangularCuts(1.5, 75.));
  else if(channel_ == muon) triangc_sel.reset(new uhh2::AndSelection(ctx)); // always true (no triangular cuts for muon channel)
  ///

  /// top-tagging
  const TopJetId topjetID = AndId<TopJet>(Type2TopTag(110,240,Type2TopTag::MassType::groomed), Tau32());
  const float minDR_topjet_jet(1.2);

  toptagevt_sel.reset(new TopTagEventSelection(topjetID, minDR_topjet_jet));
  h_flag_toptagevent = ctx.declare_event_output<int>("flag_toptagevent");
  ///

  //// TTBAR KINEMATICAL RECO
  const std::string ttbar_gen_label ("ttbargen");
  const std::string tstar_gen_label ("tstargen");
  
  ttgenprod   .reset(new TTbarGenProducer(ctx, ttbar_gen_label, false));
  tstargenprod.reset(new TStarGenProducer(ctx, tstar_gen_label, false));
  reco_primlep.reset(new PrimaryLepton(ctx));
  tstar_reco  .reset(new HighMassTstarReconstruction(ctx, TstarNeutrinoReconstruction, "TstarReconstruction"));
  tstar_ttag_reco  .reset(new TstarTopTagReconstruction(ctx, NeutrinoReconstruction, "TstarReconstruction", topjetID, 1.2));
  tstar_chi2  .reset(new TstarChi2Discriminator      (ctx, "TstarReconstruction"));
  tstar_ttag_chi2  .reset(new TstarChi2DiscriminatorTTAG      (ctx, "TstarReconstruction"));

  tstar_match .reset(new TstarCorrectMatchDiscriminator    (ctx, "TstarReconstruction"));

  h_hyps = ctx.get_handle<std::vector<TstarReconstructionHypothesis>>("TstarReconstruction");
  ////

  //// HISTS
  chi2min_h  .reset(new HypothesisHistsOwn(ctx, "chi2min__HypHists", "TstarReconstruction", "Chi2")); 
  chi2min_ttag_h  .reset(new HypothesisHistsOwn(ctx, "chi2min_ttag__HypHists", "TstarReconstruction", "Chi2")); 
  chi2min_ttag_comb_h.reset(new HypothesisHistsOwn(ctx, "chi2min_ttag_comb__HypHists","TstarReconstruction", "Chi2"));

  corrmatch_h.reset(new HypothesisHistsOwn(ctx, "corrmatch__HypHists", "TstarReconstruction", "CorrectMatch"));
 
  // set up Hists classes
  input_h_event .reset(new EventHists(ctx, "input_Event"));
  input_h_bJet  .reset(new TstarSelectionHists(ctx, "input_bJet"));
  input_h_jet   .reset(new JetHists(ctx, "input_Jets",6));
  input_h_ele   .reset(new ElectronHists(ctx, "input_Electrons"));
  input_h_muo   .reset(new MuonHists(ctx, "input_Muons"));
  input_h_topjet.reset(new TopJetHists(ctx, "input_TopJets"));

  trigger_h_event .reset(new EventHists(ctx, "trigger_Event"));
  trigger_h_bJet  .reset(new TstarSelectionHists(ctx, "trigger_bJet"));
  trigger_h_jet   .reset(new JetHists(ctx, "trigger_Jets",6));
  trigger_h_ele   .reset(new ElectronHists(ctx, "trigger_Electrons"));
  trigger_h_muo   .reset(new MuonHists(ctx, "trigger_Muons"));
  trigger_h_topjet.reset(new TopJetHists(ctx, "trigger_TopJets")); 

  lep1_h_event .reset(new EventHists(ctx, "lep1_Event"));
  lep1_h_bJet  .reset(new TstarSelectionHists(ctx, "lep1_bJet"));
  lep1_h_jet   .reset(new JetHists(ctx, "lep1_Jets",6));
  lep1_h_ele   .reset(new ElectronHists(ctx, "lep1_Electrons"));
  lep1_h_muo   .reset(new MuonHists(ctx, "lep1_Muons"));
  lep1_h_topjet.reset(new TopJetHists(ctx, "lep1_TopJets")); 

  jet2_h_event .reset(new EventHists(ctx, "jet2_Event"));
  jet2_h_bJet  .reset(new TstarSelectionHists(ctx, "jet2_bJet"));
  jet2_h_jet   .reset(new JetHists(ctx, "jet2_Jets",6));
  jet2_h_ele   .reset(new ElectronHists(ctx, "jet2_Electrons"));
  jet2_h_muo   .reset(new MuonHists(ctx, "jet2_Muons"));
  jet2_h_topjet.reset(new TopJetHists(ctx, "jet2_TopJets")); 

  jet1_h_event .reset(new EventHists(ctx, "jet1_Event"));
  jet1_h_bJet  .reset(new TstarSelectionHists(ctx, "jet1_bJet"));
  jet1_h_jet   .reset(new JetHists(ctx, "jet1_Jets",6));
  jet1_h_ele   .reset(new ElectronHists(ctx, "jet1_Electrons"));
  jet1_h_muo   .reset(new MuonHists(ctx, "jet1_Muons"));
  jet1_h_topjet.reset(new TopJetHists(ctx, "jet1_TopJets")); 
  
  twodcut_h_event.reset(new EventHists(ctx, "twodcut_Event"));
  twodcut_h_bJet.reset(new TstarSelectionHists(ctx, "twodcut_bJet"));
  twodcut_h_jet.reset(new JetHists(ctx, "twodcut_Jets",6));
  twodcut_h_ele.reset(new ElectronHists(ctx, "twodcut_Electrons"));
  twodcut_h_muo.reset(new MuonHists(ctx, "twodcut_Muons"));
  twodcut_h_topjet.reset(new TopJetHists(ctx, "twodcut_TopJets")); 

  triangc_h_event .reset(new EventHists(ctx, "triangc_Event"));
  triangc_h_bJet  .reset(new TstarSelectionHists(ctx, "triangc_bJet"));
  triangc_h_jet   .reset(new JetHists(ctx, "triangc_Jets",6));
  triangc_h_ele   .reset(new ElectronHists(ctx, "triangc_Electrons"));
  triangc_h_muo   .reset(new MuonHists(ctx, "triangc_Muons"));
  triangc_h_topjet.reset(new TopJetHists(ctx, "triangc_TopJets")); 

  toptagevt_h_event .reset(new EventHists(ctx, "toptagevt_Event"));
  toptagevt_h_bJet  .reset(new TstarSelectionHists(ctx, "toptagevt_bJet"));
  toptagevt_h_jet   .reset(new JetHists(ctx, "toptagevt_Jets",6));
  toptagevt_h_ele   .reset(new ElectronHists(ctx, "toptagevt_Electrons"));
  toptagevt_h_muo   .reset(new MuonHists(ctx, "toptagevt_Muons"));
  toptagevt_h_topjet.reset(new TopJetHists(ctx, "toptagevt_TopJets")); 

  output_h_event .reset(new EventHists(ctx, "output_Event"));
  output_h_bJet  .reset(new TstarSelectionHists(ctx, "output_bJet"));
  output_h_jet   .reset(new JetHists(ctx, "output_Jets",6));
  output_h_ele   .reset(new ElectronHists(ctx, "output_Electrons"));
  output_h_muo   .reset(new MuonHists(ctx, "output_Muons"));
  output_h_topjet.reset(new TopJetHists(ctx, "output_TopJets"));
  ////
}


bool TstarSelectionControl::process(uhh2::Event& event){

  // COMMON MODULES
  bool pass_common = common->process(event);
    if(!pass_common) return false;

    //Reweight Top Jet Pt:
    //ttbar_reweight->process(event);

  //dump input content
  input_h_event ->fill(event);
  input_h_bJet  ->fill(event);
  input_h_jet   ->fill(event);
  input_h_ele   ->fill(event);
  input_h_muo   ->fill(event);
  input_h_topjet->fill(event);

  //// OBJ CLEANING
  jet_cleaner1       ->process(event);
  topjet_IDcleaner    ->process(event);
  topjet_corrector    ->process(event);
  //topjetER_smearer  ->process(event);
  topjetlepton_cleaner->process(event);
  topjet_cleaner      ->process(event);
  sort_by_pt<Jet>(*event.jets);
  sort_by_pt<TopJet>(*event.topjets);
  ////
 
  //// HLT selection
  const bool pass_trigger = trigger_sel->passes(event);
  if(!pass_trigger) return false;

  trigger_h_event  ->fill(event);
  trigger_h_bJet   ->fill(event);
  trigger_h_jet    ->fill(event);
  trigger_h_ele    ->fill(event);
  trigger_h_muo    ->fill(event);
  trigger_h_topjet ->fill(event);
  ////

  //// LEPTON selection
  const bool pass_lep1 = lep1_sel->passes(event);
  if(!pass_lep1) return false;

  lep1_h_event  ->fill(event);
  lep1_h_bJet   ->fill(event);
  lep1_h_jet    ->fill(event);
  lep1_h_ele    ->fill(event);
  lep1_h_muo    ->fill(event);
  lep1_h_topjet ->fill(event);
  ////

 /// lepton-2Dcut boolean
  
  const bool pass_twodcut = twodcut_sel->passes(event);
  if(!pass_twodcut) return false;
 
  twodcut_h_event  ->fill(event);
  twodcut_h_bJet   ->fill(event);
  twodcut_h_jet    ->fill(event);
  twodcut_h_ele    ->fill(event);
  twodcut_h_muo    ->fill(event);
  twodcut_h_topjet ->fill(event);
    
////

  //Second Jet Cleaner
  jet_cleaner2    ->process(event);

  //// JET selection
  /// 2nd AK4 jet selection 
  const bool pass_jet2 = jet2_sel->passes(event);
  if(!pass_jet2) return false;

  jet2_h_event  ->fill(event);
  jet2_h_bJet   ->fill(event);
  jet2_h_jet    ->fill(event);
  jet2_h_ele    ->fill(event);
  jet2_h_muo    ->fill(event);
  jet2_h_topjet ->fill(event);
  ///

  /// 1st AK4 jet selection
  const bool pass_jet1 = jet1_sel->passes(event);
  if(!pass_jet1) return false;

  jet1_h_event  ->fill(event);
  jet1_h_bJet   ->fill(event);
  jet1_h_jet    ->fill(event);
  jet1_h_ele    ->fill(event);
  jet1_h_muo    ->fill(event);
  jet1_h_topjet ->fill(event);
  ////

  //// TRIANGULAR-CUTS selection [e+jets only]
  /*const bool pass_triangc = triangc_sel->passes(event);
  if(!pass_triangc) return false;

  triangc_h_event  ->fill(event);
  triangc_h_bJet   ->fill(event);
  triangc_h_jet    ->fill(event);
  triangc_h_ele    ->fill(event);
  triangc_h_muo    ->fill(event);
  triangc_h_topjet ->fill(event);
  */
  ////
 
 //// TOPTAG-EVENT boolean
  const bool pass_ttagevt = toptagevt_sel->passes(event);
  if(pass_ttagevt){  
  toptagevt_h_event ->fill(event);
  toptagevt_h_bJet  ->fill(event);
  toptagevt_h_jet   ->fill(event);
  toptagevt_h_ele   ->fill(event);
  toptagevt_h_muo   ->fill(event);
  toptagevt_h_topjet ->fill(event);
  }

  /* add flag_toptagevent to output ntuple */
  event.set(h_flag_toptagevent, int(pass_ttagevt));
  ////    

////SYSTEM RECO
  ////PrimeLep Reco
  reco_primlep->process(event);

if(!event.isRealData){
  ttgenprod->process(event);
  tstargenprod->process(event);
 }

//// TStar Kin Chi2 TopTag
/*
if(!pass_ttagevt){ tstar_reco->process(event); tstar_chi2->process(event); }
  else { 
    const bool pass_reco = tstar_ttag_reco->process(event);
    if(!pass_reco) { tstar_reco->process(event); tstar_chi2->process(event);}
    else{  tstar_ttag_chi2->process(event); }
  }
*/

//// TStar KIN RECO
  tstar_reco->process(event);
  tstar_chi2->process(event);

  ////Correct Match selection ////
  //tstar_match->process(event);
 

////Hypothesis selection  
  // save only the chi2-best ttbar hypothesis in output sub-ntuple
  std::vector<TstarReconstructionHypothesis>& hyps = event.get(h_hyps);

  const TstarReconstructionHypothesis* hyp = get_best_hypothesis(hyps, "Chi2");
  if(!hyp) std::runtime_error("TstarSelectionControl::process -- best hypothesis for tstar-reconstruction not found");
  if(!hyp->discriminator("Chi2")) std::cout<<"Nullpointer!"<<std::endl;
  if(hyp->discriminator("Chi2")<50){
    chi2min_h->fill(event);

    /*
    if(!pass_ttagevt){ chi2min_h->fill(event); }
    else             { chi2min_ttag_h->fill(event); }
    
    chi2min_ttag_comb_h->fill(event);
    */

    //corrmatch_h->fill(event);
     }
    
  const TstarReconstructionHypothesis hyp_obj(*hyp);
  hyps.clear();
  hyps.push_back(hyp_obj);
 ////

  // dump output content
  output_h_event  ->fill(event);
  output_h_bJet   ->fill(event);
  output_h_jet    ->fill(event);
  output_h_ele    ->fill(event);
  output_h_muo    ->fill(event);
  output_h_topjet ->fill(event);

  return true;

}

UHH2_REGISTER_ANALYSIS_MODULE(TstarSelectionControl)
