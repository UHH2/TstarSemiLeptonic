#include <iostream>
#include <memory>

#include "UHH2/common/include/MCWeight.h"
#include <UHH2/common/include/CommonModules.h>

#include "UHH2/core/include/AnalysisModule.h"
#include "UHH2/core/include/Event.h"
#include "UHH2/common/include/EventHists.h"
#include "UHH2/common/include/CleaningModules.h"
#include "UHH2/common/include/NSelections.h"
#include "UHH2/common/include/MuonHists.h"
#include "UHH2/common/include/MuonIds.h"
#include "UHH2/common/include/ElectronHists.h"
#include "UHH2/common/include/ElectronIds.h"
#include "UHH2/common/include/TauHists.h"
#include "UHH2/common/include/TauIds.h"
#include "UHH2/common/include/JetHists.h"
#include "UHH2/common/include/JetIds.h"
#include "UHH2/TstarSemiLeptonic/include/TstarSemiLeptonicSelections.h"
#include "UHH2/TstarSemiLeptonic/include/TstarSemiLeptonicUtils.h"
#include "UHH2/TstarSemiLeptonic/include/TstarPreSelectionHists.h"
#include <UHH2/TstarSemiLeptonic/include/TstarSelectionHists.h>
#include "UHH2/common/include/JetCorrections.h"
#include "UHH2/common/include/ObjectIdUtils.h"
#include "UHH2/common/include/Utils.h"
#include "UHH2/core/include/Selection.h"
#include "UHH2/common/include/TopPtReweight.h"

using namespace uhh2;

/** \brief module to produce "PreSelection" ntuples for the T*T*->ttbar gg semileptonic analysis
 *  NOTE: output ntuple contains uncleaned jets (no jet-lepton cleaning, no JER smearing)
 */
class TstarPreSelectionModule: public AnalysisModule {

 public:
  explicit TstarPreSelectionModule(Context & ctx);
  virtual bool process(Event & event) override;

 private:
  std::string channel_;
   std::unique_ptr<CommonModules>  common;
   std::unique_ptr<TopPtReweight> ttbar_reweight;

  std::unique_ptr<JetCleaner> jet_cleaner1;

  std::unique_ptr<TopJetCorrector> topjet_corrector;
  std::unique_ptr<TopJetLeptonDeltaRCleaner> topjetlepton_cleaner;
  std::unique_ptr<TopJetCleaner> topjet_cleaner;

  // declare the Selections to use
  std::unique_ptr<Selection> jet1_sel,jet2_sel, topjet1_sel, twodcut_sel, ht_sel;
  std::unique_ptr<uhh2::Selection>    b_tag_loose_sel;

  std::unique_ptr<uhh2::AndSelection> lep1_sel;
  // store the Hists collection as member variables
  std::unique_ptr<Hists> input_h_event,  input_h_bJet, input_h_jet, input_h_ele, input_h_muo, input_h_topjet;
  std::unique_ptr<Hists> lep1_h_event,  lep1_h_bJet, lep1_h_jet, lep1_h_ele, lep1_h_muo, lep1_h_topjet; 
  std::unique_ptr<Hists> jet1_h_event,  jet1_h_bJet, jet1_h_jet, jet1_h_ele, jet1_h_muo, jet1_h_topjet;
  std::unique_ptr<Hists> jet2_h_event,  jet2_h_bJet, jet2_h_jet, jet2_h_ele, jet2_h_muo, jet2_h_topjet;
  std::unique_ptr<Hists> ht_h_event,  ht_h_bJet, ht_h_jet, ht_h_ele, ht_h_muo, ht_h_topjet;
  std::unique_ptr<Hists> bTag_h_event, bTag_h_bJet, bTag_h_jet, bTag_h_ele, bTag_h_muo, bTag_h_topjet;
  bool is_mc;

  MuonId     MuId;
  ElectronId EleId;
  JetId      Btag_loose;
};

TstarPreSelectionModule::TstarPreSelectionModule(Context & ctx){
  MuId  = AndId<Muon>(MuonIDTight(), PtEtaCut(45., 2.1));
  EleId = AndId<Electron>(ElectronID_PHYS14_25ns_tight_noIso, PtEtaSCCut(50., 2.5));
  const JetId jetID(JetPFID(JetPFID::WP_LOOSE));

 ttbar_reweight.reset(new TopPtReweight(ctx,0.159,-0.00141,"","weight_ttbar",true,0.9910819));

///COMMON Modules
   common.reset(new CommonModules());
    //common->disable_mcpileupreweight();
    //common->disable_lumisel();
    common->disable_jersmear();
    //common->disable_jec();
    //common->disable_metfilters();
    //common->disable_pvfilter();
    common->switch_jetlepcleaner(true);
    common->set_electron_id(EleId);
    common->set_muon_id(MuId);
    common->set_jet_id(jetID);
    common->init(ctx);
   ///

  ///CHANNEL Selection
  channel_ = ctx.get("channel", "lepton");
  if(channel_!="muon" && channel_!="electron" && channel_!="lepton")
    throw std::runtime_error("undefined argument for 'channel' key in xml file (must be 'muon', 'electron' or 'lepton'): "+channel_);
  ///

  lep1_sel.reset(new uhh2::AndSelection(ctx));
if(channel_ == "muon"){
    lep1_sel->add<NMuonSelection>    ("muoN == 1", 1, 1);
    lep1_sel->add<NElectronSelection>("eleN == 0", 0, 0);
}
  else if(channel_ == "electron"){
    lep1_sel->add<NMuonSelection>    ("muoN == 0", 0, 0);
    lep1_sel->add<NElectronSelection>("eleN == 1", 1, 1);
}
 
  ///JET Correcton
  is_mc = ctx.get("dataset_type") == "MC";
  if (is_mc) {
    topjet_corrector.reset(new TopJetCorrector(ctx, JERFiles::Fall15_25ns_L123_AK8PFchs_MC));     
  } else {
    topjet_corrector.reset(new TopJetCorrector(ctx, JERFiles::Fall15_25ns_L123_AK8PFchs_DATA));
  }

  jet_cleaner1.reset(new JetCleaner(ctx, 15., 2.4));
 
  topjetlepton_cleaner.reset(new TopJetLeptonDeltaRCleaner(.8));
  topjet_cleaner.reset(new TopJetCleaner(ctx, TopJetId(PtEtaCut(250., 2.4))));
  /// 

  /// SELECTIONS                
   jet1_sel.reset(new NJetSelection(4,-1, JetId(PtEtaCut(50., 2.4)))); 
  // jet2_sel.reset(new NJetSelection(1, -1, JetId(PtEtaCut(150., 2.4)))); 
  ///

 ///b-Tag
  Btag_loose = CSVBTag(CSVBTag::WP_LOOSE);
  b_tag_loose_sel.reset(new NJetSelection(2,-1, Btag_loose));
  ///

 ///HT
  ht_sel.reset(new HtSelection(500., -1));
  ///


  ///HIST Classes
  input_h_event.reset(new EventHists(ctx, "input_Event"));
  input_h_bJet  .reset(new TstarSelectionHists(ctx, "input_bJet"));
  input_h_jet.reset(new JetHists(ctx, "input_Jets"));
  input_h_ele.reset(new ElectronHists(ctx, "input_Electrons"));
  input_h_muo.reset(new MuonHists(ctx, "input_Muons"));
  input_h_topjet.reset(new TopJetHists(ctx, "input_TopJets"));

  lep1_h_event .reset(new EventHists(ctx, "lep1_Event"));
  lep1_h_bJet  .reset(new TstarSelectionHists(ctx, "lep1_bJet"));
  lep1_h_jet   .reset(new JetHists(ctx, "lep1_Jets",6));
  lep1_h_ele   .reset(new ElectronHists(ctx, "lep1_Electrons"));
  lep1_h_muo   .reset(new MuonHists(ctx, "lep1_Muons"));
  lep1_h_topjet.reset(new TopJetHists(ctx, "lep1_TopJets")); 
 
  jet1_h_event .reset(new EventHists(ctx, "jet1_Event"));
  jet1_h_bJet  .reset(new TstarSelectionHists(ctx, "jet1_bJet"));
  jet1_h_jet   .reset(new JetHists(ctx, "jet1_Jets",6));
  jet1_h_ele   .reset(new ElectronHists(ctx, "jet1_Electrons"));
  jet1_h_muo   .reset(new MuonHists(ctx, "jet1_Muons"));
  jet1_h_topjet.reset(new TopJetHists(ctx, "jet1_TopJets")); 

  jet2_h_event .reset(new EventHists(ctx, "jet2_Event"));
  jet2_h_bJet  .reset(new TstarSelectionHists(ctx, "jet2_bJet"));
  jet2_h_jet   .reset(new JetHists(ctx, "jet2_Jets",6));
  jet2_h_ele   .reset(new ElectronHists(ctx, "jet2_Electrons"));
  jet2_h_muo   .reset(new MuonHists(ctx, "jet2_Muons"));
  jet2_h_topjet.reset(new TopJetHists(ctx, "jet2_TopJets")); 

  bTag_h_event .reset(new EventHists(ctx, "bTag_Event"));
  bTag_h_bJet  .reset(new TstarSelectionHists(ctx, "bTag_bJet"));
  bTag_h_jet   .reset(new JetHists(ctx, "bTag_Jets",6));
  bTag_h_ele   .reset(new ElectronHists(ctx, "bTag_Electrons"));
  bTag_h_muo   .reset(new MuonHists(ctx, "bTag_Muons"));
  bTag_h_topjet.reset(new TopJetHists(ctx, "bTag_TopJets")); 

  ht_h_event .reset(new EventHists(ctx, "ht_Event"));
  ht_h_bJet  .reset(new TstarSelectionHists(ctx, "ht_bJet"));
  ht_h_jet   .reset(new JetHists(ctx, "ht_Jets",6));
  ht_h_ele   .reset(new ElectronHists(ctx, "ht_Electrons"));
  ht_h_muo   .reset(new MuonHists(ctx, "ht_Muons"));
  ht_h_topjet.reset(new TopJetHists(ctx, "ht_TopJets")); 

}

bool TstarPreSelectionModule::process(Event & event) {

  // COMMON MODULES
  bool pass_common = common->process(event);
    if(!pass_common) return false;

 //Reweight Top Jet Pt:
   ttbar_reweight->process(event);

  // dump input content
  input_h_event->fill(event);
  input_h_bJet   ->fill(event);
  input_h_jet->fill(event);
  input_h_ele->fill(event);
  input_h_muo->fill(event);
  input_h_topjet->fill(event);

  // Object CLEANING
  jet_cleaner1->process(event);

  topjet_corrector->process(event);
  topjetlepton_cleaner->process(event);
  topjet_cleaner->process(event);


  // LEPTON PRE-SELECTION
   const bool pass_lep1 = lep1_sel->passes(event);
  if(!pass_lep1) return false;

  lep1_h_event  ->fill(event);
  lep1_h_bJet   ->fill(event);
  lep1_h_jet    ->fill(event);
  lep1_h_ele    ->fill(event);
  lep1_h_muo    ->fill(event);
  lep1_h_topjet ->fill(event);

  // keep Jets *before cleaning* to store them in the ntuple if event is accepted
  std::unique_ptr< std::vector<Jet> > uncleaned_jets(new std::vector<Jet>(*event.jets));
  std::unique_ptr< std::vector<TopJet> > uncleaned_topjets(new std::vector<TopJet>(*event.topjets));
 
   // JET PRE-SELECTION
  bool pass_jet = jet1_sel->passes(event);
  if(!pass_jet) return false;
  
  jet1_h_event  ->fill(event);
  jet1_h_bJet   ->fill(event);
  jet1_h_jet    ->fill(event);
  jet1_h_ele    ->fill(event);
  jet1_h_muo    ->fill(event);
  jet1_h_topjet ->fill(event);
  ////
  
 // store Jets *before cleaning* in the ntuple
  event.jets->clear();
  event.jets->reserve(uncleaned_jets->size());
  for(auto & j : *uncleaned_jets) event.jets->push_back(j); 
  sort_by_pt<Jet>(*event.jets);

  event.topjets->clear();
  event.topjets->reserve(uncleaned_topjets->size());
  for(auto & j : *uncleaned_topjets) event.topjets->push_back(j); 
  sort_by_pt<TopJet>(*event.topjets);


  /*
 /// 2nd AK4 jet selection 
  const bool pass_jet2 = jet2_sel->passes(event);
  if(!pass_jet2) return false;

  jet2_h_event  ->fill(event);
  jet2_h_bJet   ->fill(event);
  jet2_h_jet    ->fill(event);
  jet2_h_ele    ->fill(event);
  jet2_h_muo    ->fill(event);
  jet2_h_topjet ->fill(event);
  ///
  */

/// b-Tag selection 
  const bool pass_bTag = b_tag_loose_sel->passes(event);
  if(!pass_bTag) return false;

  bTag_h_event  ->fill(event);
  bTag_h_bJet   ->fill(event);
  bTag_h_jet    ->fill(event);
  bTag_h_ele    ->fill(event);
  bTag_h_muo    ->fill(event);
  bTag_h_topjet ->fill(event);
  ////

///HT Cut 
  const bool pass_ht = ht_sel->passes(event);
  if(!pass_ht) return false;
  
  ht_h_event  ->fill(event);
  ht_h_bJet   ->fill(event);
  ht_h_jet    ->fill(event);
  ht_h_ele    ->fill(event);
  ht_h_muo    ->fill(event);
  ht_h_topjet ->fill(event);
  ///
  
  return true;
}

UHH2_REGISTER_ANALYSIS_MODULE(TstarPreSelectionModule)
